

//write down what all the functions do how interact

//!!!!!! calculate all variables in terms of mag arc but calculate them using ellipse arc limits
//!!!!!! remove ellipse arc var replace mag arc ones
//!!!!!! rename all starts and end
//!!!!!! redo ellipse equations in terms sine and cos

var totalRadDragCovered = 0;


//!!!!!! Convert that to rads from ellipse center
//!!!!!! place first ball
//!!!!!! loop ball placement



//this button is so I can see what current vars are
const radCircle = 2*Math.PI;

//shouldnt these two angles be the same // no relative to different centres
var ellipseStartAngle = 0; //before changed the ellipse code worked with  radCircle/4
var startMagRadArc =0; //the zero position is straight up so because we place it right then move it left need to acount for it

var ellipseEndAngle = radCircle*6/4;
 /*one px as vw* vh*/


    /*first find real center*/
    /*this is whole screen center not shape center if shape is centered should be okay ... otherwise do it for the shape
      and adjust for shapes placement*/
    var centerEllipseX = [document.documentElement.clientWidth] / 2;
    var centerEllipseY = [document.documentElement.clientHeight] / 2;

    var halfEllipseWidth = parseInt($(".bestCardsArea").css("width"), 10) / 2;
    var halfEllipseHeight  = parseInt($(".bestCardsArea").css("height"), 10) / 2;

    /*if i dont squew i dont need below and can simplify equation*/
    var rightMidY = 0;
    var leftMidX = 0;





$('button').on('click', function() {});


//!!!! If the window is resized after load these wont update if here, putting them in the methods causes lag, try using var
//Magnifiers position
    const $dial = $('.dial');   
//because not currently using a custom image with the view glass of magnifiers centre being the most central point of the image and the hand not point directly up, we have to set the rotation point in the css so rotates about the glass centre and adjust the glass so it start handle up.
$dial.css('transform', 'rotate(' + -25 + 'deg)');



//this is how much of an arc (not the proportion of its arc) the drag has covevered
//!!!! Later there will need to be a var with this that adjust for its initial rotation so that its starting radsTravelledAroundEllipsele is counted as part of its arc covered



//controlling the arc magnifier can be pulled
//!!!!later will be calculated to match where balls start and end
//!!!!alternative could the balls just trigger mouse unbind if out of rradsTravelledAroundEllipsee
//!!!! the code would then save that position as the start or end arc and would only unbind if >< than that arc
   
//These center the magnifiers point of rotation on the glass center
    const centerMagImgX = parseInt($dial.css('transform-origin').split(' ')[0]);
    const centerMagImgY = parseInt($dial.css('transform-origin').split(' ')[1]);
//These center the magnifiers point of rotation on the page adjusting for its rotation point not being central
    const centerMagGlobalX = $dial.offset().left + centerMagImgX;
    const centerMagGlobalY = $dial.offset().top + centerMagImgY;

//functions for dragging the magnifier
function getStartClickRad(event){
  //You do not drag necessarily from zero degrees so need to know start radsTravelledAroundEllipsele
  //here i add what already dragged from last time so it isnt forgotted
  const startDragRad = getRadOfARelativeToB(event.pageX, event.pageY, centerMagGlobalX, centerMagGlobalY ) + totalRadDragCovered;
  return startDragRad;
}
var calcCurrentRadDragCoveredAndApply = function (event, startDragRad){
  var currentDragRad = getRadOfARelativeToB(event.pageX, event.pageY, centerMagGlobalX, centerMagGlobalY);

  var radTravelledThisDrag = startDragRad - currentDragRad; //this way round as we want to go backwards 
  ifInArcApplyDrag(radTravelledThisDrag); 
}
function getRadOfARelativeToB(AXCoord, AYCoord,BXCoord, BYCoord){
  var radsRelative = Math.atan2(AXCoord - BXCoord,AYCoord - BYCoord);
  // here previously converted to degrees but want to keep in rads if i can
  return radsRelative;
  
}
//is this where should check if the drag is in rradsTravelledAroundEllipsee
//should it place even if out of rradsTravelledAroundEllipsee but allow to be dragged into rradsTravelledAroundEllipsee, so if decreasing arc only checks not decreasing it past bottom limit but doesnt stop it increasing even if the increase is still below the bottom threshold.
function ifInArcApplyDrag(radTravelledThisDrag){
  //apply chradsTravelledAroundEllipsee
  //!!!I've chradsTravelledAroundEllipseed the code to rad
  //if dec && >< magArcStartradsTravelledAroundEllipseRad OR if inc && >< magArcEndradsTravelledAroundEllipseRad;
 //would be better if it knew if the balls would move if not then return false if they would return true this way would be that last degree away from where should be - could be acheived by a hit the edge bool and hit the edge last movement though this wouldnt work because multiple balls
  //we only care if ball 1 is in place
 
if(!outOfArcTriggerAnimOrStop(radTravelledThisDrag)){

    //function could be improved by translate circle rads to ellipse rads
    //place balls front ball at rads function // uses calc function
    //later card magnification should go here too  


  totalRadDragCovered = radTravelledThisDrag; //the wheel uses this

   $dial.css('transform', 'rotate(' + radTravelledThisDrag + 'rad)');
  //check if should unbind

  
  }
    
}


 $dial.mousedown(function(event) {
  const startDragRad = getStartClickRad(event);
   $(document).bind('mousemove', startDragRad, function(event){
     calcCurrentRadDragCoveredAndApply(event, startDragRad);

      
   });
   //believe this is so you dont pull the image using normal drag rules
   return false;
   });                
                    
     $(document).mouseup(function() {
        $(document).unbind('mousemove');
      
    return false;
  });

//relies on the handle pointing directly up
//take an object and sets rotation
//initial rotation rad always starts zero
//cannot set once no longer at zero
//very similar to the drag code should be able to reuse more of the code

//we calc the pix for centre can use this also worth checking it is centre
//var testLocationObj = {pageX: 1000, pageY:0} //these coords should be direction straight up
//setHandleToPointToLocAndSetArcStart(testLocationObj); //initialised as zero so maybe not needed
//this code is different from end click because does not need a start location
//and the center point and end location are switched around
//it also applys the drag itself
//i think it is distinct enought
//join function with the set first ball one late
function setHandleToPointToLocAndSetArcStart(endLocation){
  var radOfEndLocation = getRadOfARelativeToB(centerMagGlobalX, centerMagGlobalY, endLocation.pageX, endLocation.pageY);
  var radToTravelToEndLocation = - radOfEndLocation; //this way round as we want to go backwards however if this is problamatic later just put the negative in the css section

  //should this be in first ball one as this function not about setting up but about putting to specific location
  startMagRadArc = radToTravelToEndLocation;
 
  ifInArcApplyDrag(radToTravelToEndLocation);
}


//!!!!!!!!!!!!!end magnifier section
//Wheel section
var radIncPerWheelClick = radCircle/100; // currently one percent of circle

var wheelListnerIncMagRad = function(e){
//need equation to move by increment
//need calculate current rotation and add
  
   ifInArcApplyDrag(-1*radIncPerWheelClick*Math.sign(e.deltaY)+ totalRadDragCovered); //not useing calcCurrentRadDragCoveredAndApply because takes coord not anh
  
  
  
  //to stop the scroll might work outside of code pen
  return false;
    }
window.addEventListener('wheel', wheelListnerIncMagRad, false);


////!!!!!!!!!!!!!!!!!!!!!! Marbles
//have a seperate function to calculate how a magnifier rad relates to a ellipse rad

//need to be calculated using ellipse calc. for 0 and radCircle

//if manage to set start position to zero would work out nice
//!!!!!this isnt rads of eclipse its rad of arc later will need a function to branch between the two
function outOfArcTriggerAnimOrStop(radsOfMagArcToTravelToZero ){
  //put the arc as declining from start to end
  
  //return false; // del later this is just for testing

//justForTestingPutObjectAtCoords2(calcMyObjectPosOnEllipse(radsOfMagArcToTravelToZero));//testing del
//testEllipse(radsOfMagArcToTravelToZero);//testing del
 
if(radsOfMagArcToTravelToZero <= startMagRadArc)  { radsOfMagArcToTravelToZero += radCircle;}
  
//var ellipseRads = convertDistTravelledToEllipseAng(radsOfMagArcToTravelToZero);
//  var locationObjTest = calcMyObjectPosOnEllipse(ellipseRads);
//justForTestingPutObjectAtCoords(locationObjTest);
  //if its less than ellipseRadsEndLimit (which should be about 1.136 so will need to calculate it using the magnifier) then it is in the range where something needs to heppen. If it is less than that and less than half the length of the arc between start and end then it is in the top half of the arc so stop the turn 
  

  var midRadPointProhibitedArc = (ellipseRadsEndLimit-startMagRadArc)/2;
    
console.log(ellipseRadsEndLimit);
 if(radsOfMagArcToTravelToZero < ellipseRadsEndLimit && radsOfMagArcToTravelToZero < midRadPointProhibitedArc)  

 {
   $(document).unbind('mousemove');
  console.log("beginning of arc reached radsOfMag < ellipseRadsEndLimit && radsOfMag < midRadPointProhibitedArc ... rads of ellipse is " +radsOfMag+ " ellipseRadsEndLimit is " + ellipseRadsEndLimit + " midRadPointProhibitedArc is " + midRadPointProhibitedArc );
  return true;}

//if turned the magnifier too far
//again unless put something to convert from mag arc to ellipse arc we have the mag end not the ellipse end
//here we are saying if it is in the bottom half of the arc. 
  else if(radsOfMagArcToTravelToZero<ellipseRadsEndLimit && radsOfMagArcToTravelToZero> midRadPointProhibitedArc){
   $(document).unbind('mousemove');
    
  console.log("end of arc reached radsOfMag < ellipseRadsEndLimit && radsOfMag > midRadPointProhibitedArc ... rads of ellipse is " +radsOfMagArcToTravelToZero+ " ellipseRadsEndLimit is " + ellipseRadsEndLimit + " midRadPointProhibitedArc is " + midRadPointProhibitedArc );
    
   runPageTransistion();
   return true;
 }else{
  // console.log("radsOfMag was in range");
   return false;}
}
function runPageTransistion(){console.log("page transistion triggered");}


//this is generating a decreasing number from the quater position it should start at and decreasing to negive 4 over 2pi as it should yet we have forward movement.
function convertDistTravelledToEllipseAng(magArcLeftToTravel){
  
 var magTotArcDistToTravelRads = radCircle+startMagRadArc;
 var magDistTravelled = magTotArcDistToTravelRads - magArcLeftToTravel;
  var ellipseAng = ellipseStartAngle - magDistTravelled; // negative is because of the direction //so should start in its starting position then decrease

    console.log(" magTotArcDistToTravelRads " + magTotArcDistToTravelRads + " magArcLeftToTravel " + magArcLeftToTravel + " magDistTravelled " + magDistTravelled + " ellipseStartAngle "+  ellipseStartAngle + " startMagRadArc " +startMagRadArc);
  return ellipseAng;
}

function calcMyObjectPosOnEllipse(ang) {

//Recalculate variables incase change screen size

//this is center of the screen not center of the shape --- though the shape is centered

    var centerEllipseX = [document.documentElement.clientWidth] / 2;
    var centerEllipseY = [document.documentElement.clientHeight] / 2;
  
  //trying to find the center based on shape top offset too large - wondering if its the editor
//var centerEllipseX = parseInt($(".bestCardsArea").css("width"), 10) / 2 + $(".bestCardsArea").offset().left;
//var centerEllipseY = parseInt($(".bestCardsArea").css("height"), 10) / 2 + $(".bestCardsArea").offset().top;

    var  halfEllipseWidth = parseInt($(".bestCardsArea").css("width"), 10) / 2; 
    var  halfEllipseHeight = parseInt($(".bestCardsArea").css("height"), 10) / 2;
 
    /*if i dont squew i dont need below and can simplify equation*/
    var rightMidY = 0;
    var leftMidX = 0;


var calculatedLocOnEllipse = { pageX:0 , pageY: 0};

 var cosA =  Math.cos(ang);
 var sinA = Math.sin(ang);
  

 if(sinA<0){ //console.log("im in the left half");
           if(cosA>0){ //" im in the left half and bottom half so left bottom ");
                     if(cosA<0.5){ //"bottom left top, halved this is the left section"); 
                                  sinA=-1;//stick left hand side
                                 //stretchDown so at its max 0.5
                                  cosA=cosA+(cosA-0.5)+(0.5-0); //first brackets tend to zero start -0.5 
                               
                                 }                           
                     else if(cosA>=0.5){
                      //"bottom left top, halved this is the right section"); 
                                  cosA=1; //stickToBottom   
                         //= desiredStart+(finish-desiredStart)*(progress-start)/(finish-start)   //stretchBackWardsLeft
                                  var whereSinAWillActuallyStart = -Math.sin(Math.acos(0.5));
                              // sinA = -1+((0--1)*(sinA-whereSinAWillActuallyStart)/(0-whereSinAWillActuallyStart));
            
                                  sinA = -1+(1)*((sinA-whereSinAWillActuallyStart)/(0-whereSinAWillActuallyStart));
          
                     }       
                     }} 
  
  
 var calculatedLocOnEllipse = { pageX:0 , pageY: 0};
     calculatedLocOnEllipse.pageX = centerEllipseX + leftMidX * cosA + halfEllipseWidth * sinA;
     calculatedLocOnEllipse.pageY = centerEllipseY + halfEllipseHeight * cosA + rightMidY * sinA;
 return calculatedLocOnEllipse;


}

//call in set variables at beginning
//should it be mag limits
//would be nice if calc ang based off coordinater fed into ellipse equation ... know x position and y will be locked thats enough for angle pick the answer that has the larger y value, then put code back in to get squared ellipse location


setEllipseLimits();
function setEllipseLimits(){
  
  

  
  
  
  //first need location of ball which is three ball widths in from the top corner
 
  // this works but i think it is better to reuse calc equation
 // var firstMarbleLoc = {pageX:0, pageY:0}
 // firstMarbleLoc.pageX = centerEllipseX + halfEllipseWidth - 300;//the 300 is 3 marble widths
 // firstMarbleLoc.pageY = centerEllipseY - halfEllipseHeight;
  //*/
  
  var quaterCircleLocMinus3marbleRadiuss = calcMyObjectPosOnEllipse( ellipseStartAngle);   
  quaterCircleLocMinus3marbleRadiuss.pageX -=300; //eigth circle take you to far left corner
  justForTestingPutObjectAtCoords(quaterCircleLocMinus3marbleRadiuss);

     // ellipseRadsEndLimit = radCircle*5/4; //this is just lifted from the ellipseCalculator //6/4 so at its locked limit, //need better way
 var endOfArcLocObj =calcMyObjectPosOnEllipse(ellipseEndAngle); // now need angle between calcmy Object pos and start magnifier
  // this code is lifted from function setHandleToPointToLocAndSetArcStart(endLocation){ - so probably need to make this section the function and take it out
  var radEndFromBegginning = getRadOfARelativeToB(centerMagGlobalX, centerMagGlobalY, endOfArcLocObj.pageX, endOfArcLocObj.pageY);
   ellipseRadsEndLimit = - radEndFromBegginning; 
  
  

  
    //then find the arc from coordinates of the center of the ellipse to the coordinate where placing it
  setHandleToPointToLocAndSetArcStart(quaterCircleLocMinus3marbleRadiuss);
  


  
  

 
  
}

function justForTestingPutObjectAtCoords(objLoc){
   $(".marbleOnShape1").css("left",  objLoc.pageX);
  $(".marbleOnShape1").css("top",  objLoc.pageY);
 
  
}
function justForTestingPutObjectAtCoords2(objLoc){
   $(".marbleOnShape2").css("left",  objLoc.pageX);
  $(".marbleOnShape2").css("top",  objLoc.pageY);
 
  
}


  